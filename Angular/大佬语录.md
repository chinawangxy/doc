## 关于学习
```
翻译完官方文档就差不多了，然后就是在实践项目中体会一些应用场景

有后端基础的话，达到熟练其实是很容易的，因为高层设计思想都是互通的。

入门之后，阅读风格指南，找到和自己的现有习惯不同的地方，思考为什么，尽量把自己的实践靠过去

入门之后，没有项目压力了，就要尽快把官方文档通读一遍，至少遇到哪个问题知道去哪一章找。

然后就是学会用模型驱动的方式去理解需求

四象限带交互的图形编辑器

建立业务模型，比如四象限工具的业务模型就是一个 “条目、价值、代价” 的列表。

把它映射到视图模型中，就是 “条目、横坐标、纵坐标” 的列表

因为价值、代价这些都是来自需求，所以称其为业务模型，而横坐标纵坐标这些都是只属于视图层的概念，所以称为视图模型

我们写的代码其实就是在处理业务模型和视图模型之间的关联。

而模板只是把视图模型用 SVG 表示出来而已。


在水平比较低的情况下，深入去学，掌握它的每一个细节，思考这个设计背后的原理。这个阶段专心学一门技术就可以。

等到水平较高了，再学习相关的技术

但是第一个阶段也仍然要放开看书，不要局限于前端，特别是在软件工程等方面下点功夫，这是很多程序员容易忽视的地方，也就容易形成你的竞争力。

精通 Angular/React/Vue 之一，阅读《代码整洁之道》，阅读敏捷相关的书籍，有机会就去实践，然后读一些关于为人处世方面的著作，让自己的心态保持开放。

```


## 关于资源
- css需要的静态资源需要就近放置
- 然后使用`./`进行相对引用
- css中的图片引用不会打包到js中
- 注意：assets应该是最后的选择，集中存放在大多数场景下都没有什么优势
- 就近放在查找、清理之类的场景下都很方便
- Scss不应该抽出来，抽出来的都是变量和scss函数
- 最理想的可维护性就是无论做什么都在同一个超小型目录下完成。

- 场景不同，真正全局性的就应该放在全局css中
- 只有局部性的才放到组件Css中
- 但是局部性的需要跟全局保持风格一致
- 因此要在定义全局样式的同时定义变量和mixin，确保组件中的可以引用它
- mixin只生成样式，不带结构(class生成那种不需要)
- 这样调整只需要修改全局变量定义中进行修改就能切换到其它色系了。
- 无论是全局样式还是局部样式都能同步收到影响
- 如果支持动态换肤，并且不需要支持IE，那就基于css variables特性来做
- 这种方式灵活可维护
- GITHUB仓库：[例子](https://github.com/zhaosiyang/angular-dynamic-theme-example)


## Angular 模块 module

[引用](https://v2.angular.cn/docs/ts/latest/guide/ngmodule.html)

不要在共享模块中把应用级单例添加到providers中。 否则如果一个惰性加载模块导入了此共享模块，就会导致它自己也生成一份此服务的实例。

也就是说，如果两个惰性加载模块都导入了一个在自身 provide 某个服务的 SharedModule，那么这个服务就是两个实例。

比如 A 和 B 都是惰性加载模块，S 是共享模块，它在自身提供了一个服务，我们本来期望这个服务是单例。但是如果 A 和 B 都导入了 S，那么这个服务就会有两个实例。

这个主要取决于你的本意是什么，这个服务是不是就应该全局只有一份的，如果是就root，如果否就 module

但实际上我很少提供在 module 上，因为提供在 component 上通常更明确

module 上的 service 实例数比较容易被误解，不如直接提供在组件上来的简单明了

反正一份组件就对应一个 service，都不用想

我一般只会区分这个服务是属于全局单例还是组件单例

模块单例没看到什么必须的场景

它的规则不是那么直观，特别是 shared 那种情况，老手都会翻车

任何在 DOM 树中位于它子树中的组件、指令、管道、服务等都可以拿到它

假如我注册到父组件的话，子组件能共享吗 答： 可以
```
我一般用声明在组件上的服务来为复杂组件建模

也就是说一个交互很复杂的组件，我就把它的主要逻辑都放在一个或多个服务上，让组件只变成一个单纯的视图

这样既达到了拆分组件的目的，也达到了统一管理模型的目的

服务就很容易用 SoC 原则来拆分了
```